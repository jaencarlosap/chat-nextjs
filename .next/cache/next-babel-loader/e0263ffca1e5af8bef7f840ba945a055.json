{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// importamos Component de React\nimport { Component } from 'react'; // importamos el client de socket.io\n\nimport io from 'socket.io-client'; // importamos fetch\n\nimport fetch from 'isomorphic-fetch';\n\nclass HomePage extends Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", {\n      field: '',\n      messages: this.props.messages\n    });\n\n    _defineProperty(this, \"handleMessage\", message => {\n      this.setState(state => ({\n        messages: state.messages.concat(message)\n      }));\n    });\n\n    _defineProperty(this, \"handleChange\", event => {\n      this.setState({\n        field: event.target.value\n      });\n    });\n\n    _defineProperty(this, \"handleSubmit\", event => {\n      event.preventDefault(); // creamos un objeto message con la fecha actual como ID y el valor del input\n\n      const message = {\n        id: new Date().getTime(),\n        value: this.state.field\n      }; // enviamos el objeto por socket al servidor\n\n      this.socket.emit('message', message); // lo agregamos a nuestro estado para que se muestre en pantalla y limpiamos el input\n\n      this.setState(state => ({\n        field: '',\n        messages: state.messages.concat(message)\n      }));\n    });\n  }\n\n  // ac치 pedimos los datos de los mensajes viejos, esto se ejecuta tanto en el cliente como en el servidor\n  static async getInitialProps({\n    req\n  }) {\n    const response = await fetch('http://localhost:3000/messages');\n    const messages = await response.json();\n    return {\n      messages\n    };\n  }\n\n  // una vez que el componente se mont칩 en el navegador nos conectamos al servidor de sockets\n  // y empezamos a recibimos el evento `message` del servidor\n  componentDidMount() {\n    this.socket = io('http://localhost:3000/');\n    this.socket.on('message', this.handleMessage);\n  } // cuando el componente se va a desmontar es importante que dejemos de escuchar el evento\n  // y que cerremos la conexi칩n por sockets, esto es para evitar problemas de que lleguen mensajes\n\n\n  componentWillUnmount() {\n    this.socket.off('message', this.handleMessage);\n    this.socket.close();\n  } // cuando llega un mensaje del servidor lo agregamos al estado de nuestra p치gina\n\n\n  render() {\n    return __jsx(\"main\", null, __jsx(\"div\", null, __jsx(\"ul\", null, this.state.messages.map(message => __jsx(\"li\", {\n      key: message.id\n    }, __jsx(\"span\", {\n      className: \"hljs-name\"\n    }, message.value)))), __jsx(\"form\", {\n      onSubmit: this.handleSubmit\n    }, __jsx(\"input\", {\n      onChange: this.handleChange,\n      type: \"text\",\n      placeholder: \"Hola Platzi!\",\n      value: this.state.field\n    }), __jsx(\"button\", null, \"Enviar\"))));\n  }\n\n}\n\n_defineProperty(HomePage, \"defaultProps\", {\n  messages: []\n});\n\nexport default HomePage;","map":null,"metadata":{},"sourceType":"module"}